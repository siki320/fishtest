#
# Autogenerated by Thrift Compiler (0.9.2)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface:
  def WriteCoordinate(self, id, biz, coord, status, trace_id):
    """
    Parameters:
     - id
     - biz
     - coord
     - status
     - trace_id
    """
    pass

  def WriteStatus(self, id, biz, status, trace_id):
    """
    Parameters:
     - id
     - biz
     - status
     - trace_id
    """
    pass

  def DeleteCoordinate(self, id, biz, coord, trace_id):
    """
    Parameters:
     - id
     - biz
     - coord
     - trace_id
    """
    pass

  def GetCoordinatesInArea(self, bizs, area, seconds, search_filter, count, return_fields, trace_id):
    """
    Parameters:
     - bizs
     - area
     - seconds
     - search_filter
     - count
     - return_fields
     - trace_id
    """
    pass

  def GetCoordinatesInAreaParallel(self, nodes, count, return_fields, trace_id):
    """
    Parameters:
     - nodes
     - count
     - return_fields
     - trace_id
    """
    pass

  def GetCoordinatesCountInArea(self, bizs, area, seconds, search_filter, trace_id):
    """
    Parameters:
     - bizs
     - area
     - seconds
     - search_filter
     - trace_id
    """
    pass

  def GetCoordinatesByIds(self, biz, ids, seconds, output_coord_type, trace_id):
    """
    Parameters:
     - biz
     - ids
     - seconds
     - output_coord_type
     - trace_id
    """
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def WriteCoordinate(self, id, biz, coord, status, trace_id):
    """
    Parameters:
     - id
     - biz
     - coord
     - status
     - trace_id
    """
    self.send_WriteCoordinate(id, biz, coord, status, trace_id)
    return self.recv_WriteCoordinate()

  def send_WriteCoordinate(self, id, biz, coord, status, trace_id):
    self._oprot.writeMessageBegin('WriteCoordinate', TMessageType.CALL, self._seqid)
    args = WriteCoordinate_args()
    args.id = id
    args.biz = biz
    args.coord = coord
    args.status = status
    args.trace_id = trace_id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_WriteCoordinate(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = WriteCoordinate_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "WriteCoordinate failed: unknown result");

  def WriteStatus(self, id, biz, status, trace_id):
    """
    Parameters:
     - id
     - biz
     - status
     - trace_id
    """
    self.send_WriteStatus(id, biz, status, trace_id)
    return self.recv_WriteStatus()

  def send_WriteStatus(self, id, biz, status, trace_id):
    self._oprot.writeMessageBegin('WriteStatus', TMessageType.CALL, self._seqid)
    args = WriteStatus_args()
    args.id = id
    args.biz = biz
    args.status = status
    args.trace_id = trace_id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_WriteStatus(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = WriteStatus_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "WriteStatus failed: unknown result");

  def DeleteCoordinate(self, id, biz, coord, trace_id):
    """
    Parameters:
     - id
     - biz
     - coord
     - trace_id
    """
    self.send_DeleteCoordinate(id, biz, coord, trace_id)
    return self.recv_DeleteCoordinate()

  def send_DeleteCoordinate(self, id, biz, coord, trace_id):
    self._oprot.writeMessageBegin('DeleteCoordinate', TMessageType.CALL, self._seqid)
    args = DeleteCoordinate_args()
    args.id = id
    args.biz = biz
    args.coord = coord
    args.trace_id = trace_id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_DeleteCoordinate(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = DeleteCoordinate_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "DeleteCoordinate failed: unknown result");

  def GetCoordinatesInArea(self, bizs, area, seconds, search_filter, count, return_fields, trace_id):
    """
    Parameters:
     - bizs
     - area
     - seconds
     - search_filter
     - count
     - return_fields
     - trace_id
    """
    self.send_GetCoordinatesInArea(bizs, area, seconds, search_filter, count, return_fields, trace_id)
    return self.recv_GetCoordinatesInArea()

  def send_GetCoordinatesInArea(self, bizs, area, seconds, search_filter, count, return_fields, trace_id):
    self._oprot.writeMessageBegin('GetCoordinatesInArea', TMessageType.CALL, self._seqid)
    args = GetCoordinatesInArea_args()
    args.bizs = bizs
    args.area = area
    args.seconds = seconds
    args.search_filter = search_filter
    args.count = count
    args.return_fields = return_fields
    args.trace_id = trace_id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetCoordinatesInArea(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = GetCoordinatesInArea_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.le is not None:
      raise result.le
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetCoordinatesInArea failed: unknown result");

  def GetCoordinatesInAreaParallel(self, nodes, count, return_fields, trace_id):
    """
    Parameters:
     - nodes
     - count
     - return_fields
     - trace_id
    """
    self.send_GetCoordinatesInAreaParallel(nodes, count, return_fields, trace_id)
    return self.recv_GetCoordinatesInAreaParallel()

  def send_GetCoordinatesInAreaParallel(self, nodes, count, return_fields, trace_id):
    self._oprot.writeMessageBegin('GetCoordinatesInAreaParallel', TMessageType.CALL, self._seqid)
    args = GetCoordinatesInAreaParallel_args()
    args.nodes = nodes
    args.count = count
    args.return_fields = return_fields
    args.trace_id = trace_id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetCoordinatesInAreaParallel(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = GetCoordinatesInAreaParallel_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.le is not None:
      raise result.le
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetCoordinatesInAreaParallel failed: unknown result");

  def GetCoordinatesCountInArea(self, bizs, area, seconds, search_filter, trace_id):
    """
    Parameters:
     - bizs
     - area
     - seconds
     - search_filter
     - trace_id
    """
    self.send_GetCoordinatesCountInArea(bizs, area, seconds, search_filter, trace_id)
    return self.recv_GetCoordinatesCountInArea()

  def send_GetCoordinatesCountInArea(self, bizs, area, seconds, search_filter, trace_id):
    self._oprot.writeMessageBegin('GetCoordinatesCountInArea', TMessageType.CALL, self._seqid)
    args = GetCoordinatesCountInArea_args()
    args.bizs = bizs
    args.area = area
    args.seconds = seconds
    args.search_filter = search_filter
    args.trace_id = trace_id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetCoordinatesCountInArea(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = GetCoordinatesCountInArea_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.le is not None:
      raise result.le
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetCoordinatesCountInArea failed: unknown result");

  def GetCoordinatesByIds(self, biz, ids, seconds, output_coord_type, trace_id):
    """
    Parameters:
     - biz
     - ids
     - seconds
     - output_coord_type
     - trace_id
    """
    self.send_GetCoordinatesByIds(biz, ids, seconds, output_coord_type, trace_id)
    return self.recv_GetCoordinatesByIds()

  def send_GetCoordinatesByIds(self, biz, ids, seconds, output_coord_type, trace_id):
    self._oprot.writeMessageBegin('GetCoordinatesByIds', TMessageType.CALL, self._seqid)
    args = GetCoordinatesByIds_args()
    args.biz = biz
    args.ids = ids
    args.seconds = seconds
    args.output_coord_type = output_coord_type
    args.trace_id = trace_id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetCoordinatesByIds(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = GetCoordinatesByIds_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.le is not None:
      raise result.le
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetCoordinatesByIds failed: unknown result");


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["WriteCoordinate"] = Processor.process_WriteCoordinate
    self._processMap["WriteStatus"] = Processor.process_WriteStatus
    self._processMap["DeleteCoordinate"] = Processor.process_DeleteCoordinate
    self._processMap["GetCoordinatesInArea"] = Processor.process_GetCoordinatesInArea
    self._processMap["GetCoordinatesInAreaParallel"] = Processor.process_GetCoordinatesInAreaParallel
    self._processMap["GetCoordinatesCountInArea"] = Processor.process_GetCoordinatesCountInArea
    self._processMap["GetCoordinatesByIds"] = Processor.process_GetCoordinatesByIds

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_WriteCoordinate(self, seqid, iprot, oprot):
    args = WriteCoordinate_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = WriteCoordinate_result()
    result.success = self._handler.WriteCoordinate(args.id, args.biz, args.coord, args.status, args.trace_id)
    oprot.writeMessageBegin("WriteCoordinate", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_WriteStatus(self, seqid, iprot, oprot):
    args = WriteStatus_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = WriteStatus_result()
    result.success = self._handler.WriteStatus(args.id, args.biz, args.status, args.trace_id)
    oprot.writeMessageBegin("WriteStatus", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_DeleteCoordinate(self, seqid, iprot, oprot):
    args = DeleteCoordinate_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = DeleteCoordinate_result()
    result.success = self._handler.DeleteCoordinate(args.id, args.biz, args.coord, args.trace_id)
    oprot.writeMessageBegin("DeleteCoordinate", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetCoordinatesInArea(self, seqid, iprot, oprot):
    args = GetCoordinatesInArea_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetCoordinatesInArea_result()
    try:
      result.success = self._handler.GetCoordinatesInArea(args.bizs, args.area, args.seconds, args.search_filter, args.count, args.return_fields, args.trace_id)
    except lbspp.ttypes.LbsppException, le:
      result.le = le
    oprot.writeMessageBegin("GetCoordinatesInArea", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetCoordinatesInAreaParallel(self, seqid, iprot, oprot):
    args = GetCoordinatesInAreaParallel_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetCoordinatesInAreaParallel_result()
    try:
      result.success = self._handler.GetCoordinatesInAreaParallel(args.nodes, args.count, args.return_fields, args.trace_id)
    except lbspp.ttypes.LbsppException, le:
      result.le = le
    oprot.writeMessageBegin("GetCoordinatesInAreaParallel", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetCoordinatesCountInArea(self, seqid, iprot, oprot):
    args = GetCoordinatesCountInArea_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetCoordinatesCountInArea_result()
    try:
      result.success = self._handler.GetCoordinatesCountInArea(args.bizs, args.area, args.seconds, args.search_filter, args.trace_id)
    except lbspp.ttypes.LbsppException, le:
      result.le = le
    oprot.writeMessageBegin("GetCoordinatesCountInArea", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetCoordinatesByIds(self, seqid, iprot, oprot):
    args = GetCoordinatesByIds_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetCoordinatesByIds_result()
    try:
      result.success = self._handler.GetCoordinatesByIds(args.biz, args.ids, args.seconds, args.output_coord_type, args.trace_id)
    except lbspp.ttypes.LbsppException, le:
      result.le = le
    oprot.writeMessageBegin("GetCoordinatesByIds", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class WriteCoordinate_args:
  """
  Attributes:
   - id
   - biz
   - coord
   - status
   - trace_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'id', None, None, ), # 1
    (2, TType.STRUCT, 'biz', (lbspp.ttypes.Business, lbspp.ttypes.Business.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'coord', (lbspp.ttypes.Coordinate, lbspp.ttypes.Coordinate.thrift_spec), None, ), # 3
    (4, TType.MAP, 'status', (TType.STRING,None,TType.I64,None), None, ), # 4
    (5, TType.I64, 'trace_id', None, None, ), # 5
  )

  def __init__(self, id=None, biz=None, coord=None, status=None, trace_id=None,):
    self.id = id
    self.biz = biz
    self.coord = coord
    self.status = status
    self.trace_id = trace_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.id = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.biz = lbspp.ttypes.Business()
          self.biz.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.coord = lbspp.ttypes.Coordinate()
          self.coord.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.status = {}
          (_ktype1, _vtype2, _size0 ) = iprot.readMapBegin()
          for _i4 in xrange(_size0):
            _key5 = iprot.readString();
            _val6 = iprot.readI64();
            self.status[_key5] = _val6
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.trace_id = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WriteCoordinate_args')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I64, 1)
      oprot.writeI64(self.id)
      oprot.writeFieldEnd()
    if self.biz is not None:
      oprot.writeFieldBegin('biz', TType.STRUCT, 2)
      self.biz.write(oprot)
      oprot.writeFieldEnd()
    if self.coord is not None:
      oprot.writeFieldBegin('coord', TType.STRUCT, 3)
      self.coord.write(oprot)
      oprot.writeFieldEnd()
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.MAP, 4)
      oprot.writeMapBegin(TType.STRING, TType.I64, len(self.status))
      for kiter7,viter8 in self.status.items():
        oprot.writeString(kiter7)
        oprot.writeI64(viter8)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.trace_id is not None:
      oprot.writeFieldBegin('trace_id', TType.I64, 5)
      oprot.writeI64(self.trace_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.id)
    value = (value * 31) ^ hash(self.biz)
    value = (value * 31) ^ hash(self.coord)
    value = (value * 31) ^ hash(self.status)
    value = (value * 31) ^ hash(self.trace_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WriteCoordinate_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (lbspp.ttypes.RespMsg, lbspp.ttypes.RespMsg.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = lbspp.ttypes.RespMsg()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WriteCoordinate_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WriteStatus_args:
  """
  Attributes:
   - id
   - biz
   - status
   - trace_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'id', None, None, ), # 1
    (2, TType.STRUCT, 'biz', (lbspp.ttypes.Business, lbspp.ttypes.Business.thrift_spec), None, ), # 2
    (3, TType.MAP, 'status', (TType.STRING,None,TType.I64,None), None, ), # 3
    (4, TType.I64, 'trace_id', None, None, ), # 4
  )

  def __init__(self, id=None, biz=None, status=None, trace_id=None,):
    self.id = id
    self.biz = biz
    self.status = status
    self.trace_id = trace_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.id = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.biz = lbspp.ttypes.Business()
          self.biz.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.status = {}
          (_ktype10, _vtype11, _size9 ) = iprot.readMapBegin()
          for _i13 in xrange(_size9):
            _key14 = iprot.readString();
            _val15 = iprot.readI64();
            self.status[_key14] = _val15
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.trace_id = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WriteStatus_args')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I64, 1)
      oprot.writeI64(self.id)
      oprot.writeFieldEnd()
    if self.biz is not None:
      oprot.writeFieldBegin('biz', TType.STRUCT, 2)
      self.biz.write(oprot)
      oprot.writeFieldEnd()
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.I64, len(self.status))
      for kiter16,viter17 in self.status.items():
        oprot.writeString(kiter16)
        oprot.writeI64(viter17)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.trace_id is not None:
      oprot.writeFieldBegin('trace_id', TType.I64, 4)
      oprot.writeI64(self.trace_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.id)
    value = (value * 31) ^ hash(self.biz)
    value = (value * 31) ^ hash(self.status)
    value = (value * 31) ^ hash(self.trace_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WriteStatus_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (lbspp.ttypes.RespMsg, lbspp.ttypes.RespMsg.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = lbspp.ttypes.RespMsg()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WriteStatus_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DeleteCoordinate_args:
  """
  Attributes:
   - id
   - biz
   - coord
   - trace_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'id', None, None, ), # 1
    (2, TType.STRUCT, 'biz', (lbspp.ttypes.Business, lbspp.ttypes.Business.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'coord', (lbspp.ttypes.Coordinate, lbspp.ttypes.Coordinate.thrift_spec), None, ), # 3
    (4, TType.I64, 'trace_id', None, None, ), # 4
  )

  def __init__(self, id=None, biz=None, coord=None, trace_id=None,):
    self.id = id
    self.biz = biz
    self.coord = coord
    self.trace_id = trace_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.id = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.biz = lbspp.ttypes.Business()
          self.biz.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.coord = lbspp.ttypes.Coordinate()
          self.coord.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.trace_id = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DeleteCoordinate_args')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I64, 1)
      oprot.writeI64(self.id)
      oprot.writeFieldEnd()
    if self.biz is not None:
      oprot.writeFieldBegin('biz', TType.STRUCT, 2)
      self.biz.write(oprot)
      oprot.writeFieldEnd()
    if self.coord is not None:
      oprot.writeFieldBegin('coord', TType.STRUCT, 3)
      self.coord.write(oprot)
      oprot.writeFieldEnd()
    if self.trace_id is not None:
      oprot.writeFieldBegin('trace_id', TType.I64, 4)
      oprot.writeI64(self.trace_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.id)
    value = (value * 31) ^ hash(self.biz)
    value = (value * 31) ^ hash(self.coord)
    value = (value * 31) ^ hash(self.trace_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DeleteCoordinate_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (lbspp.ttypes.RespMsg, lbspp.ttypes.RespMsg.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = lbspp.ttypes.RespMsg()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DeleteCoordinate_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetCoordinatesInArea_args:
  """
  Attributes:
   - bizs
   - area
   - seconds
   - search_filter
   - count
   - return_fields
   - trace_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'bizs', (TType.STRUCT,(lbspp.ttypes.Business, lbspp.ttypes.Business.thrift_spec)), None, ), # 1
    (2, TType.STRUCT, 'area', (lbspp.ttypes.Area, lbspp.ttypes.Area.thrift_spec), None, ), # 2
    (3, TType.I64, 'seconds', None, None, ), # 3
    (4, TType.STRUCT, 'search_filter', (lbspp.ttypes.SearchFilter, lbspp.ttypes.SearchFilter.thrift_spec), None, ), # 4
    (5, TType.I64, 'count', None, None, ), # 5
    (6, TType.BOOL, 'return_fields', None, None, ), # 6
    (7, TType.I64, 'trace_id', None, None, ), # 7
  )

  def __init__(self, bizs=None, area=None, seconds=None, search_filter=None, count=None, return_fields=None, trace_id=None,):
    self.bizs = bizs
    self.area = area
    self.seconds = seconds
    self.search_filter = search_filter
    self.count = count
    self.return_fields = return_fields
    self.trace_id = trace_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.bizs = []
          (_etype21, _size18) = iprot.readListBegin()
          for _i22 in xrange(_size18):
            _elem23 = lbspp.ttypes.Business()
            _elem23.read(iprot)
            self.bizs.append(_elem23)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.area = lbspp.ttypes.Area()
          self.area.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.seconds = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.search_filter = lbspp.ttypes.SearchFilter()
          self.search_filter.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.count = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.return_fields = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I64:
          self.trace_id = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetCoordinatesInArea_args')
    if self.bizs is not None:
      oprot.writeFieldBegin('bizs', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.bizs))
      for iter24 in self.bizs:
        iter24.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.area is not None:
      oprot.writeFieldBegin('area', TType.STRUCT, 2)
      self.area.write(oprot)
      oprot.writeFieldEnd()
    if self.seconds is not None:
      oprot.writeFieldBegin('seconds', TType.I64, 3)
      oprot.writeI64(self.seconds)
      oprot.writeFieldEnd()
    if self.search_filter is not None:
      oprot.writeFieldBegin('search_filter', TType.STRUCT, 4)
      self.search_filter.write(oprot)
      oprot.writeFieldEnd()
    if self.count is not None:
      oprot.writeFieldBegin('count', TType.I64, 5)
      oprot.writeI64(self.count)
      oprot.writeFieldEnd()
    if self.return_fields is not None:
      oprot.writeFieldBegin('return_fields', TType.BOOL, 6)
      oprot.writeBool(self.return_fields)
      oprot.writeFieldEnd()
    if self.trace_id is not None:
      oprot.writeFieldBegin('trace_id', TType.I64, 7)
      oprot.writeI64(self.trace_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.bizs)
    value = (value * 31) ^ hash(self.area)
    value = (value * 31) ^ hash(self.seconds)
    value = (value * 31) ^ hash(self.search_filter)
    value = (value * 31) ^ hash(self.count)
    value = (value * 31) ^ hash(self.return_fields)
    value = (value * 31) ^ hash(self.trace_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetCoordinatesInArea_result:
  """
  Attributes:
   - success
   - le
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(lbspp.ttypes.CoordinateBean, lbspp.ttypes.CoordinateBean.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'le', (lbspp.ttypes.LbsppException, lbspp.ttypes.LbsppException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, le=None,):
    self.success = success
    self.le = le

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype28, _size25) = iprot.readListBegin()
          for _i29 in xrange(_size25):
            _elem30 = lbspp.ttypes.CoordinateBean()
            _elem30.read(iprot)
            self.success.append(_elem30)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.le = lbspp.ttypes.LbsppException()
          self.le.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetCoordinatesInArea_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter31 in self.success:
        iter31.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.le is not None:
      oprot.writeFieldBegin('le', TType.STRUCT, 1)
      self.le.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.le)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetCoordinatesInAreaParallel_args:
  """
  Attributes:
   - nodes
   - count
   - return_fields
   - trace_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'nodes', (TType.STRUCT,(lbspp.ttypes.BizSearchPara, lbspp.ttypes.BizSearchPara.thrift_spec)), None, ), # 1
    (2, TType.I64, 'count', None, None, ), # 2
    (3, TType.BOOL, 'return_fields', None, None, ), # 3
    (4, TType.I64, 'trace_id', None, None, ), # 4
  )

  def __init__(self, nodes=None, count=None, return_fields=None, trace_id=None,):
    self.nodes = nodes
    self.count = count
    self.return_fields = return_fields
    self.trace_id = trace_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.nodes = []
          (_etype35, _size32) = iprot.readListBegin()
          for _i36 in xrange(_size32):
            _elem37 = lbspp.ttypes.BizSearchPara()
            _elem37.read(iprot)
            self.nodes.append(_elem37)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.count = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.return_fields = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.trace_id = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetCoordinatesInAreaParallel_args')
    if self.nodes is not None:
      oprot.writeFieldBegin('nodes', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.nodes))
      for iter38 in self.nodes:
        iter38.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.count is not None:
      oprot.writeFieldBegin('count', TType.I64, 2)
      oprot.writeI64(self.count)
      oprot.writeFieldEnd()
    if self.return_fields is not None:
      oprot.writeFieldBegin('return_fields', TType.BOOL, 3)
      oprot.writeBool(self.return_fields)
      oprot.writeFieldEnd()
    if self.trace_id is not None:
      oprot.writeFieldBegin('trace_id', TType.I64, 4)
      oprot.writeI64(self.trace_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.nodes)
    value = (value * 31) ^ hash(self.count)
    value = (value * 31) ^ hash(self.return_fields)
    value = (value * 31) ^ hash(self.trace_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetCoordinatesInAreaParallel_result:
  """
  Attributes:
   - success
   - le
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(lbspp.ttypes.CoordinateBean, lbspp.ttypes.CoordinateBean.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'le', (lbspp.ttypes.LbsppException, lbspp.ttypes.LbsppException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, le=None,):
    self.success = success
    self.le = le

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype42, _size39) = iprot.readListBegin()
          for _i43 in xrange(_size39):
            _elem44 = lbspp.ttypes.CoordinateBean()
            _elem44.read(iprot)
            self.success.append(_elem44)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.le = lbspp.ttypes.LbsppException()
          self.le.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetCoordinatesInAreaParallel_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter45 in self.success:
        iter45.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.le is not None:
      oprot.writeFieldBegin('le', TType.STRUCT, 1)
      self.le.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.le)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetCoordinatesCountInArea_args:
  """
  Attributes:
   - bizs
   - area
   - seconds
   - search_filter
   - trace_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'bizs', (TType.STRUCT,(lbspp.ttypes.Business, lbspp.ttypes.Business.thrift_spec)), None, ), # 1
    (2, TType.STRUCT, 'area', (lbspp.ttypes.Area, lbspp.ttypes.Area.thrift_spec), None, ), # 2
    (3, TType.I64, 'seconds', None, None, ), # 3
    (4, TType.STRUCT, 'search_filter', (lbspp.ttypes.SearchFilter, lbspp.ttypes.SearchFilter.thrift_spec), None, ), # 4
    (5, TType.I64, 'trace_id', None, None, ), # 5
  )

  def __init__(self, bizs=None, area=None, seconds=None, search_filter=None, trace_id=None,):
    self.bizs = bizs
    self.area = area
    self.seconds = seconds
    self.search_filter = search_filter
    self.trace_id = trace_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.bizs = []
          (_etype49, _size46) = iprot.readListBegin()
          for _i50 in xrange(_size46):
            _elem51 = lbspp.ttypes.Business()
            _elem51.read(iprot)
            self.bizs.append(_elem51)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.area = lbspp.ttypes.Area()
          self.area.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.seconds = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.search_filter = lbspp.ttypes.SearchFilter()
          self.search_filter.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.trace_id = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetCoordinatesCountInArea_args')
    if self.bizs is not None:
      oprot.writeFieldBegin('bizs', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.bizs))
      for iter52 in self.bizs:
        iter52.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.area is not None:
      oprot.writeFieldBegin('area', TType.STRUCT, 2)
      self.area.write(oprot)
      oprot.writeFieldEnd()
    if self.seconds is not None:
      oprot.writeFieldBegin('seconds', TType.I64, 3)
      oprot.writeI64(self.seconds)
      oprot.writeFieldEnd()
    if self.search_filter is not None:
      oprot.writeFieldBegin('search_filter', TType.STRUCT, 4)
      self.search_filter.write(oprot)
      oprot.writeFieldEnd()
    if self.trace_id is not None:
      oprot.writeFieldBegin('trace_id', TType.I64, 5)
      oprot.writeI64(self.trace_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.bizs)
    value = (value * 31) ^ hash(self.area)
    value = (value * 31) ^ hash(self.seconds)
    value = (value * 31) ^ hash(self.search_filter)
    value = (value * 31) ^ hash(self.trace_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetCoordinatesCountInArea_result:
  """
  Attributes:
   - success
   - le
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'le', (lbspp.ttypes.LbsppException, lbspp.ttypes.LbsppException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, le=None,):
    self.success = success
    self.le = le

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.le = lbspp.ttypes.LbsppException()
          self.le.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetCoordinatesCountInArea_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.le is not None:
      oprot.writeFieldBegin('le', TType.STRUCT, 1)
      self.le.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.le)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetCoordinatesByIds_args:
  """
  Attributes:
   - biz
   - ids
   - seconds
   - output_coord_type
   - trace_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'biz', (lbspp.ttypes.Business, lbspp.ttypes.Business.thrift_spec), None, ), # 1
    (2, TType.LIST, 'ids', (TType.I64,None), None, ), # 2
    (3, TType.I64, 'seconds', None, None, ), # 3
    (4, TType.I32, 'output_coord_type', None, None, ), # 4
    (5, TType.I64, 'trace_id', None, None, ), # 5
  )

  def __init__(self, biz=None, ids=None, seconds=None, output_coord_type=None, trace_id=None,):
    self.biz = biz
    self.ids = ids
    self.seconds = seconds
    self.output_coord_type = output_coord_type
    self.trace_id = trace_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.biz = lbspp.ttypes.Business()
          self.biz.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.ids = []
          (_etype56, _size53) = iprot.readListBegin()
          for _i57 in xrange(_size53):
            _elem58 = iprot.readI64();
            self.ids.append(_elem58)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.seconds = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.output_coord_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.trace_id = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetCoordinatesByIds_args')
    if self.biz is not None:
      oprot.writeFieldBegin('biz', TType.STRUCT, 1)
      self.biz.write(oprot)
      oprot.writeFieldEnd()
    if self.ids is not None:
      oprot.writeFieldBegin('ids', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.ids))
      for iter59 in self.ids:
        oprot.writeI64(iter59)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.seconds is not None:
      oprot.writeFieldBegin('seconds', TType.I64, 3)
      oprot.writeI64(self.seconds)
      oprot.writeFieldEnd()
    if self.output_coord_type is not None:
      oprot.writeFieldBegin('output_coord_type', TType.I32, 4)
      oprot.writeI32(self.output_coord_type)
      oprot.writeFieldEnd()
    if self.trace_id is not None:
      oprot.writeFieldBegin('trace_id', TType.I64, 5)
      oprot.writeI64(self.trace_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.biz)
    value = (value * 31) ^ hash(self.ids)
    value = (value * 31) ^ hash(self.seconds)
    value = (value * 31) ^ hash(self.output_coord_type)
    value = (value * 31) ^ hash(self.trace_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetCoordinatesByIds_result:
  """
  Attributes:
   - success
   - le
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(lbspp.ttypes.CoordinateBean, lbspp.ttypes.CoordinateBean.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'le', (lbspp.ttypes.LbsppException, lbspp.ttypes.LbsppException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, le=None,):
    self.success = success
    self.le = le

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype63, _size60) = iprot.readListBegin()
          for _i64 in xrange(_size60):
            _elem65 = lbspp.ttypes.CoordinateBean()
            _elem65.read(iprot)
            self.success.append(_elem65)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.le = lbspp.ttypes.LbsppException()
          self.le.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetCoordinatesByIds_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter66 in self.success:
        iter66.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.le is not None:
      oprot.writeFieldBegin('le', TType.STRUCT, 1)
      self.le.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.le)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
