#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Error:
  CLIENT_INVALID_COORD = 1
  CLIENT_INVALID_ARGUMENT = 2
  SERVER_ERROR = 3

  _VALUES_TO_NAMES = {
    1: "CLIENT_INVALID_COORD",
    2: "CLIENT_INVALID_ARGUMENT",
    3: "SERVER_ERROR",
  }

  _NAMES_TO_VALUES = {
    "CLIENT_INVALID_COORD": 1,
    "CLIENT_INVALID_ARGUMENT": 2,
    "SERVER_ERROR": 3,
  }

class CoordType:
  BAIDU = 1
  SOSOGCJ = 2
  WGS84 = 3
  NONE = 4

  _VALUES_TO_NAMES = {
    1: "BAIDU",
    2: "SOSOGCJ",
    3: "WGS84",
    4: "NONE",
  }

  _NAMES_TO_VALUES = {
    "BAIDU": 1,
    "SOSOGCJ": 2,
    "WGS84": 3,
    "NONE": 4,
  }

class CID_PARM:
  CID_PARM_ALL = 0
  CID_PARM_ONLY_CITY = 1

  _VALUES_TO_NAMES = {
    0: "CID_PARM_ALL",
    1: "CID_PARM_ONLY_CITY",
  }

  _NAMES_TO_VALUES = {
    "CID_PARM_ALL": 0,
    "CID_PARM_ONLY_CITY": 1,
  }

class ExtraFieldsSpec:
  EXTRA_FIELDS_GPS_INFO = 0
  EXTRA_FIELDS_RT_STATUS = 1
  EXTRA_FIELDS_LISTEN_STATUS = 2
  EXTRA_FIELDS_ANGLE = 3
  EXTRA_FIELDS_GRID_ID = 4

  _VALUES_TO_NAMES = {
    0: "EXTRA_FIELDS_GPS_INFO",
    1: "EXTRA_FIELDS_RT_STATUS",
    2: "EXTRA_FIELDS_LISTEN_STATUS",
    3: "EXTRA_FIELDS_ANGLE",
    4: "EXTRA_FIELDS_GRID_ID",
  }

  _NAMES_TO_VALUES = {
    "EXTRA_FIELDS_GPS_INFO": 0,
    "EXTRA_FIELDS_RT_STATUS": 1,
    "EXTRA_FIELDS_LISTEN_STATUS": 2,
    "EXTRA_FIELDS_ANGLE": 3,
    "EXTRA_FIELDS_GRID_ID": 4,
  }


class LocsvrException(TException):
  """
  Attributes:
   - errcode
   - errmsg
   - details
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'errcode', None, None, ), # 1
    (2, TType.STRING, 'errmsg', None, None, ), # 2
    (3, TType.MAP, 'details', (TType.STRING,None,TType.STRING,None), None, ), # 3
  )

  def __init__(self, errcode=None, errmsg=None, details=None,):
    self.errcode = errcode
    self.errmsg = errmsg
    self.details = details

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.errcode = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.errmsg = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.details = {}
          (_ktype1, _vtype2, _size0 ) = iprot.readMapBegin() 
          for _i4 in xrange(_size0):
            _key5 = iprot.readString();
            _val6 = iprot.readString();
            self.details[_key5] = _val6
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LocsvrException')
    if self.errcode is not None:
      oprot.writeFieldBegin('errcode', TType.I32, 1)
      oprot.writeI32(self.errcode)
      oprot.writeFieldEnd()
    if self.errmsg is not None:
      oprot.writeFieldBegin('errmsg', TType.STRING, 2)
      oprot.writeString(self.errmsg)
      oprot.writeFieldEnd()
    if self.details is not None:
      oprot.writeFieldBegin('details', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.details))
      for kiter7,viter8 in self.details.items():
        oprot.writeString(kiter7)
        oprot.writeString(viter8)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Business:
  """
  Attributes:
   - id
   - type
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'id', None, None, ), # 1
    (2, TType.I64, 'type', None, None, ), # 2
  )

  def __init__(self, id=None, type=None,):
    self.id = id
    self.type = type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.id = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.type = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Business')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I64, 1)
      oprot.writeI64(self.id)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I64, 2)
      oprot.writeI64(self.type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.id is None:
      raise TProtocol.TProtocolException(message='Required field id is unset!')
    if self.type is None:
      raise TProtocol.TProtocolException(message='Required field type is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Gpsinfo:
  """
  Attributes:
   - accuracy
   - direction
   - speed
   - angle
  """

  thrift_spec = (
    None, # 0
    (1, TType.DOUBLE, 'accuracy', None, None, ), # 1
    (2, TType.DOUBLE, 'direction', None, None, ), # 2
    (3, TType.DOUBLE, 'speed', None, None, ), # 3
    (4, TType.DOUBLE, 'angle', None, None, ), # 4
  )

  def __init__(self, accuracy=None, direction=None, speed=None, angle=None,):
    self.accuracy = accuracy
    self.direction = direction
    self.speed = speed
    self.angle = angle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.DOUBLE:
          self.accuracy = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.direction = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.DOUBLE:
          self.speed = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.DOUBLE:
          self.angle = iprot.readDouble();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Gpsinfo')
    if self.accuracy is not None:
      oprot.writeFieldBegin('accuracy', TType.DOUBLE, 1)
      oprot.writeDouble(self.accuracy)
      oprot.writeFieldEnd()
    if self.direction is not None:
      oprot.writeFieldBegin('direction', TType.DOUBLE, 2)
      oprot.writeDouble(self.direction)
      oprot.writeFieldEnd()
    if self.speed is not None:
      oprot.writeFieldBegin('speed', TType.DOUBLE, 3)
      oprot.writeDouble(self.speed)
      oprot.writeFieldEnd()
    if self.angle is not None:
      oprot.writeFieldBegin('angle', TType.DOUBLE, 4)
      oprot.writeDouble(self.angle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.accuracy is None:
      raise TProtocol.TProtocolException(message='Required field accuracy is unset!')
    if self.direction is None:
      raise TProtocol.TProtocolException(message='Required field direction is unset!')
    if self.speed is None:
      raise TProtocol.TProtocolException(message='Required field speed is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Coordinate:
  """
  Attributes:
   - lng
   - lat
   - org_coord_type
   - timestamp
   - gps_info
   - rt_status
   - listen_status
   - angle
   - grid_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.DOUBLE, 'lng', None, None, ), # 1
    (2, TType.DOUBLE, 'lat', None, None, ), # 2
    (3, TType.I32, 'org_coord_type', None, None, ), # 3
    (4, TType.I64, 'timestamp', None, None, ), # 4
    (5, TType.STRUCT, 'gps_info', (Gpsinfo, Gpsinfo.thrift_spec), None, ), # 5
    (6, TType.I32, 'rt_status', None, None, ), # 6
    (7, TType.I32, 'listen_status', None, None, ), # 7
    (8, TType.DOUBLE, 'angle', None, None, ), # 8
    (9, TType.STRING, 'grid_id', None, None, ), # 9
  )

  def __init__(self, lng=None, lat=None, org_coord_type=None, timestamp=None, gps_info=None, rt_status=None, listen_status=None, angle=None, grid_id=None,):
    self.lng = lng
    self.lat = lat
    self.org_coord_type = org_coord_type
    self.timestamp = timestamp
    self.gps_info = gps_info
    self.rt_status = rt_status
    self.listen_status = listen_status
    self.angle = angle
    self.grid_id = grid_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.DOUBLE:
          self.lng = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.lat = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.org_coord_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.gps_info = Gpsinfo()
          self.gps_info.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.rt_status = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.listen_status = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.DOUBLE:
          self.angle = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.grid_id = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Coordinate')
    if self.lng is not None:
      oprot.writeFieldBegin('lng', TType.DOUBLE, 1)
      oprot.writeDouble(self.lng)
      oprot.writeFieldEnd()
    if self.lat is not None:
      oprot.writeFieldBegin('lat', TType.DOUBLE, 2)
      oprot.writeDouble(self.lat)
      oprot.writeFieldEnd()
    if self.org_coord_type is not None:
      oprot.writeFieldBegin('org_coord_type', TType.I32, 3)
      oprot.writeI32(self.org_coord_type)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 4)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.gps_info is not None:
      oprot.writeFieldBegin('gps_info', TType.STRUCT, 5)
      self.gps_info.write(oprot)
      oprot.writeFieldEnd()
    if self.rt_status is not None:
      oprot.writeFieldBegin('rt_status', TType.I32, 6)
      oprot.writeI32(self.rt_status)
      oprot.writeFieldEnd()
    if self.listen_status is not None:
      oprot.writeFieldBegin('listen_status', TType.I32, 7)
      oprot.writeI32(self.listen_status)
      oprot.writeFieldEnd()
    if self.angle is not None:
      oprot.writeFieldBegin('angle', TType.DOUBLE, 8)
      oprot.writeDouble(self.angle)
      oprot.writeFieldEnd()
    if self.grid_id is not None:
      oprot.writeFieldBegin('grid_id', TType.STRING, 9)
      oprot.writeString(self.grid_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.lng is None:
      raise TProtocol.TProtocolException(message='Required field lng is unset!')
    if self.lat is None:
      raise TProtocol.TProtocolException(message='Required field lat is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CoordinateBean:
  """
  Attributes:
   - id
   - coord_info
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'id', None, None, ), # 1
    (2, TType.STRUCT, 'coord_info', (Coordinate, Coordinate.thrift_spec), None, ), # 2
  )

  def __init__(self, id=None, coord_info=None,):
    self.id = id
    self.coord_info = coord_info

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.id = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.coord_info = Coordinate()
          self.coord_info.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CoordinateBean')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I64, 1)
      oprot.writeI64(self.id)
      oprot.writeFieldEnd()
    if self.coord_info is not None:
      oprot.writeFieldBegin('coord_info', TType.STRUCT, 2)
      self.coord_info.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.id is None:
      raise TProtocol.TProtocolException(message='Required field id is unset!')
    if self.coord_info is None:
      raise TProtocol.TProtocolException(message='Required field coord_info is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Cityinfo:
  """
  Attributes:
   - cityid
   - city_desc
   - countyid
   - county_desc
   - countryid
   - country_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'cityid', None, None, ), # 1
    (2, TType.STRING, 'city_desc', None, None, ), # 2
    (3, TType.I32, 'countyid', None, None, ), # 3
    (4, TType.STRING, 'county_desc', None, None, ), # 4
    (5, TType.I32, 'countryid', None, None, ), # 5
    (6, TType.STRING, 'country_desc', None, None, ), # 6
  )

  def __init__(self, cityid=None, city_desc=None, countyid=None, county_desc=None, countryid=None, country_desc=None,):
    self.cityid = cityid
    self.city_desc = city_desc
    self.countyid = countyid
    self.county_desc = county_desc
    self.countryid = countryid
    self.country_desc = country_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cityid = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.city_desc = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.countyid = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.county_desc = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.countryid = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.country_desc = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Cityinfo')
    if self.cityid is not None:
      oprot.writeFieldBegin('cityid', TType.I32, 1)
      oprot.writeI32(self.cityid)
      oprot.writeFieldEnd()
    if self.city_desc is not None:
      oprot.writeFieldBegin('city_desc', TType.STRING, 2)
      oprot.writeString(self.city_desc)
      oprot.writeFieldEnd()
    if self.countyid is not None:
      oprot.writeFieldBegin('countyid', TType.I32, 3)
      oprot.writeI32(self.countyid)
      oprot.writeFieldEnd()
    if self.county_desc is not None:
      oprot.writeFieldBegin('county_desc', TType.STRING, 4)
      oprot.writeString(self.county_desc)
      oprot.writeFieldEnd()
    if self.countryid is not None:
      oprot.writeFieldBegin('countryid', TType.I32, 5)
      oprot.writeI32(self.countryid)
      oprot.writeFieldEnd()
    if self.country_desc is not None:
      oprot.writeFieldBegin('country_desc', TType.STRING, 6)
      oprot.writeString(self.country_desc)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.cityid is None:
      raise TProtocol.TProtocolException(message='Required field cityid is unset!')
    if self.city_desc is None:
      raise TProtocol.TProtocolException(message='Required field city_desc is unset!')
    if self.countyid is None:
      raise TProtocol.TProtocolException(message='Required field countyid is unset!')
    if self.county_desc is None:
      raise TProtocol.TProtocolException(message='Required field county_desc is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CityinfoBean:
  """
  Attributes:
   - id
   - city_info
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'id', None, None, ), # 1
    (2, TType.STRUCT, 'city_info', (Cityinfo, Cityinfo.thrift_spec), None, ), # 2
  )

  def __init__(self, id=None, city_info=None,):
    self.id = id
    self.city_info = city_info

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.id = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.city_info = Cityinfo()
          self.city_info.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CityinfoBean')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I64, 1)
      oprot.writeI64(self.id)
      oprot.writeFieldEnd()
    if self.city_info is not None:
      oprot.writeFieldBegin('city_info', TType.STRUCT, 2)
      self.city_info.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.id is None:
      raise TProtocol.TProtocolException(message='Required field id is unset!')
    if self.city_info is None:
      raise TProtocol.TProtocolException(message='Required field city_info is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CoordinateCityinfoBean:
  """
  Attributes:
   - id
   - coord_info
   - city_info
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'id', None, None, ), # 1
    (2, TType.STRUCT, 'coord_info', (Coordinate, Coordinate.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'city_info', (Cityinfo, Cityinfo.thrift_spec), None, ), # 3
  )

  def __init__(self, id=None, coord_info=None, city_info=None,):
    self.id = id
    self.coord_info = coord_info
    self.city_info = city_info

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.id = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.coord_info = Coordinate()
          self.coord_info.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.city_info = Cityinfo()
          self.city_info.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CoordinateCityinfoBean')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I64, 1)
      oprot.writeI64(self.id)
      oprot.writeFieldEnd()
    if self.coord_info is not None:
      oprot.writeFieldBegin('coord_info', TType.STRUCT, 2)
      self.coord_info.write(oprot)
      oprot.writeFieldEnd()
    if self.city_info is not None:
      oprot.writeFieldBegin('city_info', TType.STRUCT, 3)
      self.city_info.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.id is None:
      raise TProtocol.TProtocolException(message='Required field id is unset!')
    if self.coord_info is None:
      raise TProtocol.TProtocolException(message='Required field coord_info is unset!')
    if self.city_info is None:
      raise TProtocol.TProtocolException(message='Required field city_info is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Filter:
  """
  Attributes:
   - extra_fields_spec
   - timeout
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'extra_fields_spec', None, None, ), # 1
    (2, TType.I32, 'timeout', None, None, ), # 2
  )

  def __init__(self, extra_fields_spec=None, timeout=None,):
    self.extra_fields_spec = extra_fields_spec
    self.timeout = timeout

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.extra_fields_spec = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.timeout = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Filter')
    if self.extra_fields_spec is not None:
      oprot.writeFieldBegin('extra_fields_spec', TType.I64, 1)
      oprot.writeI64(self.extra_fields_spec)
      oprot.writeFieldEnd()
    if self.timeout is not None:
      oprot.writeFieldBegin('timeout', TType.I32, 2)
      oprot.writeI32(self.timeout)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
